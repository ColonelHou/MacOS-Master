

##### JVM体系
````markdown
1. 类装载器       :(加载、连接(验证/准备/解析)、初始化、使用、卸载)
2. JVM内存结构
3. GC算法 垃圾回收
4. GC分析 命令调优
````

##### 垃圾回收算法
```markdown
1. 标记-清除算法        : 标记存活的,
2. 标记-整理（压缩）算法 : 移动存活对象
3. 复制算法
4. 分代收集算法
```

##### 垃圾收集器
```markdown
1. 串行收集器 : 单线程, 发生停顿 （新:复制算法; 老:标记-整理算法）
2. ParNew(串行的多线程版):
3. 并行收集器：
4. CMS（并发-标记-清除）： 最短回收停顿时间为目标的收集器
   优点:
       1. 停顿时间短，但是总的 GC 时间长
   缺点:
       1. CPU 敏感的, 抢占CPU
       2. 总的 GC 时间长
       3. 无法处理浮动垃圾(GC过程中 程序还在运行产生的垃圾)
       4. 内存碎片
       5. 内存空间不足(GC中, 程序还在运行申请空间不足时)
5. G1: 
   优点:
       1. 
   缺点:
       1. 可预测停顿时间
       2. 无内存碎片
       3. 保留了分代收集
       4. 并发并行, 提升资源利用
```



##### Heap = 新生代(Eden8+S01+S11) + 老年代
```markdown
# 问题1: 为什么要有Survivor? 
        如果没有, Eden上gc一次 就送老年代, 老年代很快就满了(FullGC),耗时,app响应速度
  解决: a. 增加老年代空间 导致一次fullgc时间更长
       b. 减少老年代空间 导致fullgc太频繁
  18次minorgc还活着才送到老年代

# 问题2: 不什么要用两个Survivor?
        内存碎片化
```

##### GCRoot是什么
```markdown
# https://yq.aliyun.com/articles/91017?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&2017531&utm_content=m_22117
1. java虚拟机栈(栈帧中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象。
3. 方法区中的常量引用的对象。
4. 本地方法栈中JNI本地方法的引用对象。
```

##### 四种引用 
```markdown
1. 强引用: 宁愿抛OOM也不愿意回收
2. 软引用: 空间不足就会 回收（缓存一些东西）
3. 弱引用: 不管内存够不够都会回收
4. 虚引用: 主要用于检测对象是否已经从内存中删除，跟踪对象被垃圾回收器回收的活动
```

#### finalize() 方法
```markdown
1. 回收不可达对象, 两次标记, 第一次标记并判断是否覆盖finalize; 如没, 第二次标记并回收
                如果有: 对象放F-Queue队列,Finalizer线程触发这个方法, 不会等他执行完
                
```